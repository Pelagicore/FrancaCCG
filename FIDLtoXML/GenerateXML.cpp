/*
    Copyright (c) 2015, Pelagicore AB.
    All rights reserved.
    
    This software was orgininally developed as part of the Master's Thesis
    "Franca IDL C Code Generator - Development and Evaluation of New
    Tools for Franca IDL" conducted at Chalmers University of Technology
    2015 by Jesper Lundkvist (jesperlundkvist@gmail.com).
    
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>.
*/



/* Generate D-Bus XML Introspection from .fidl file
 * v0.1
 * Based on Test.C generated by BNFC
 */
#include <stdio.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include "Parser.H"
#include "Absyn.H"
#include "XMLGenerator.h"
#include "CustomTypesParser.h"


int main(int argc, char ** argv)
{
    if (argv[1] == NULL) {
        fprintf(stderr, "Error: No .fidl file given.\n");
        exit(1);
    }

    FILE *input;
    std::string pathToImportFile = "";
    if (argc > 1) {
        input = fopen(argv[1], "r");
        if (!input) {
            fprintf(stderr, "Error opening input file.\n");
            exit(1);
        }
    
        // To solve imports in the fidl file, we need to save the folder path.
        std::string tmp_pathToImportFile = argv[1];
        size_t posOfLastSlash = tmp_pathToImportFile.find_last_of("/");
        if (posOfLastSlash != std::string::npos) {
            pathToImportFile = tmp_pathToImportFile.substr(0, posOfLastSlash);
        }
    } 
    else {
        input = stdin;
    }
  
    
    // Output file for D-Bus XML Introspection
    char* givenFile = argv[1];

    // If source file has the format XYZ.fidl, name the output file XYZ.xml
    // Otherwise, if it is called XYZ*, name it XYZ*.xml
  
    std::string outputFilename = givenFile;
    int found = outputFilename.rfind(".fidl");
    if (found != -1) {
        outputFilename.replace(found, 5, "");
    }
    outputFilename.append(".xml");
  
    std::ofstream output;
    output.open(outputFilename.c_str());
  
  
    // Temporarily redirect cout, so that we can save the line number of any parse error.
    // This is done rather than change Parser.C since Parser is auto-generated and will be
    // regenerated each time bnfc is run.
    std::streambuf* oldCoutStreamBuf = std::cout.rdbuf();
    std::ostringstream strCout;
    std::cout.rdbuf(strCout.rdbuf());

    // Parse the fidl file
    Program *parse_tree = pProgram(input);
  
    // Restore old cout and save the contents of temp cout.
    std::cout.rdbuf(oldCoutStreamBuf);
    std::string parserOutput = strCout.str();
  
    if (parse_tree) {
  
        /* NOT USED FOR THIS PROJECT
        // #include "Printer.H" to use
        printf("\nParse Succesful!\n");
        printf("\n[Abstract Syntax]\n");
        ShowAbsyn *s = new ShowAbsyn();
        printf("%s\n\n", s->show(parse_tree));
        printf("[Linearized Tree]\n");
        PrintAbsyn *p = new PrintAbsyn();
        printf("%s\n\n", p->print(parse_tree));
        */
    
    
        // Generate XML file
        GenerateDBusXML *g2 = new GenerateDBusXML();
        g2->createCustomTypesList(parse_tree, pathToImportFile);
        output << g2->generate(parse_tree, pathToImportFile);
        output.close();
        std::cout << "FIDLtoXML successfully finished generating D-Bus XML Introspection for Franca IDL file " << argv[1] << std::endl;
    
        // Print generated file
        //std::ifstream generatedFile(outputFilename.c_str());
        //std::string templine;
        //while (getline(generatedFile, templine)) {
        //    std::cout << templine << std::endl;
        //}
    } else {
  
        // If there are parse errors, find the line number of the parse error and print that line
    
        size_t indexOfLineNbr = parserOutput.rfind("line ");
        if (indexOfLineNbr != -1) {
            // An error message containing a line number was found. Save the line number.
            std::string lineNbrStr = parserOutput.substr(indexOfLineNbr + 5, parserOutput.length());
            //std::cout << "lineNbrStr = \"" << lineNbrStr << "\"" << std::endl;
            int lineNbr;
            std::istringstream (lineNbrStr) >> lineNbr;

            // Reopen the file to find the line with errors. Not the best solution but works.
            std::ifstream theFidlFile(argv[1]);
            std::string currentLine;
            if (theFidlFile.is_open()) {
                for (int i = 0; i < lineNbr; i++) {
                    std::getline(theFidlFile, currentLine);
                    if (i == lineNbr - 1) {
                        // Print the content of line number of parse error
                        std::cerr << "Syntax error at line " << lineNbr << ":" << std::endl << currentLine << std::endl;
                    }
                }
                theFidlFile.close();
            }
        }
        std::cerr << "Aborting code generation." << std::endl;
        return 1;
    }
  
    return 0;
}

